{"version":3,"file":"diagnostics-storage.js","sourceRoot":"","sources":["../../../src/diagnostics/diagnostics-storage.ts"],"names":[],"mappings":"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","sourcesContent":["import { getGlobalScope } from '../global-scope';\nimport { ILogger } from '../logger';\nimport { HistogramStats } from './diagnostics-client';\n\nconst MAX_PERSISTENT_STORAGE_EVENTS_COUNT = 10;\n\n// Database configuration\nconst DB_VERSION = 1;\n\n// Table names for different diagnostics types\nexport const TABLE_NAMES = {\n  TAGS: 'tags',\n  COUNTERS: 'counters',\n  HISTOGRAMS: 'histograms',\n  EVENTS: 'events',\n  INTERNAL: 'internal', // New table for internal storage like flush timestamps\n} as const;\n\n// Keys for internal storage table\nexport const INTERNAL_KEYS = {\n  LAST_FLUSH_TIMESTAMP: 'last_flush_timestamp',\n} as const;\n\n// Record interfaces for each table\nexport interface TagRecord {\n  key: string;\n  value: string;\n}\n\nexport interface CounterRecord {\n  key: string;\n  value: number;\n}\n\nexport interface HistogramRecord {\n  key: string;\n  count: number;\n  min: number;\n  max: number;\n  sum: number;\n}\n\nexport interface EventRecord {\n  id?: number; // Auto-increment primary key\n  event_name: string;\n  time: number;\n  event_properties: Record<string, any>;\n}\n\nexport interface InternalRecord {\n  key: string;\n  value: string;\n}\n\nexport interface IDiagnosticsStorage {\n  /**\n   * Set multiple tags in a single transaction (batch operation)\n   * Promise never rejects - errors are logged and operation continues gracefully\n   */\n  setTags(tags: Record<string, string>): Promise<void>;\n  /**\n   * Increment multiple counters in a single transaction (batch operation)\n   * Uses read-modify-write pattern to accumulate with existing values\n   * Promise never rejects - errors are logged and operation continues gracefully\n   */\n  incrementCounters(counters: Record<string, number>): Promise<void>;\n  /**\n   * Set multiple histogram stats in a single transaction (batch operation)\n   * Uses read-modify-write pattern to accumulate count/sum and update min/max with existing values\n   * Promise never rejects - errors are logged and operation continues gracefully\n   */\n  setHistogramStats(\n    histogramStats: Record<string, { count: number; min: number; max: number; sum: number }>,\n  ): Promise<void>;\n  /**\n   * Add multiple event records in a single transaction (batch operation)\n   * Promise never rejects - errors are logged and operation continues gracefully\n   */\n  addEventRecords(\n    events: Array<{ event_name: string; time: number; event_properties: Record<string, any> }>,\n  ): Promise<void>;\n\n  setLastFlushTimestamp(timestamp: number): Promise<void>;\n\n  getLastFlushTimestamp(): Promise<number | undefined>;\n\n  /**\n   * Get all data except internal data from storage and clear it\n   */\n  getAllAndClear(): Promise<{\n    tags: TagRecord[];\n    counters: CounterRecord[];\n    histogramStats: HistogramRecord[];\n    events: EventRecord[];\n  }>;\n}\n\n/**\n * Purpose-specific IndexedDB storage for diagnostics data\n * Provides optimized methods for each type of diagnostics data\n */\nexport class DiagnosticsStorage implements IDiagnosticsStorage {\n  dbPromise: Promise<IDBDatabase> | null = null;\n  dbName: string;\n  logger: ILogger;\n\n  constructor(apiKey: string, logger: ILogger) {\n    this.logger = logger;\n    this.dbName = `AMP_diagnostics_${apiKey.substring(0, 10)}`;\n  }\n\n  /**\n   * Check if IndexedDB is supported in the current environment\n   * @returns true if IndexedDB is available, false otherwise\n   */\n  static isSupported(): boolean {\n    return getGlobalScope()?.indexedDB !== undefined;\n  }\n\n  async getDB(): Promise<IDBDatabase> {\n    if (!this.dbPromise) {\n      this.dbPromise = this.openDB();\n    }\n    return this.dbPromise;\n  }\n\n  openDB(): Promise<IDBDatabase> {\n    return new Promise((resolve, reject) => {\n      const request = indexedDB.open(this.dbName, DB_VERSION);\n\n      request.onerror = () => {\n        // Clear dbPromise when it rejects for the first time\n        this.dbPromise = null;\n        reject(new Error('Failed to open IndexedDB'));\n      };\n\n      request.onsuccess = () => {\n        const db = request.result;\n        // Clear dbPromise when connection was on but went off later\n        db.onclose = () => {\n          this.dbPromise = null;\n          this.logger.debug('DiagnosticsStorage: DB connection closed.');\n        };\n\n        db.onerror = (event) => {\n          this.logger.debug('DiagnosticsStorage: A global database error occurred.', event);\n          db.close();\n        };\n        resolve(db);\n      };\n\n      request.onupgradeneeded = (event) => {\n        const db = (event.target as IDBOpenDBRequest).result;\n        this.createTables(db);\n      };\n    });\n  }\n\n  createTables(db: IDBDatabase): void {\n    // Create tags table\n    if (!db.objectStoreNames.contains(TABLE_NAMES.TAGS)) {\n      db.createObjectStore(TABLE_NAMES.TAGS, { keyPath: 'key' });\n    }\n\n    // Create counters table\n    if (!db.objectStoreNames.contains(TABLE_NAMES.COUNTERS)) {\n      db.createObjectStore(TABLE_NAMES.COUNTERS, { keyPath: 'key' });\n    }\n\n    // Create histograms table for storing histogram stats (count, min, max, sum)\n    if (!db.objectStoreNames.contains(TABLE_NAMES.HISTOGRAMS)) {\n      db.createObjectStore(TABLE_NAMES.HISTOGRAMS, {\n        keyPath: 'key',\n      });\n    }\n\n    // Create events table\n    if (!db.objectStoreNames.contains(TABLE_NAMES.EVENTS)) {\n      const eventsStore = db.createObjectStore(TABLE_NAMES.EVENTS, {\n        keyPath: 'id',\n        autoIncrement: true,\n      });\n\n      // Create index on time for chronological queries\n      eventsStore.createIndex('time_idx', 'time', { unique: false });\n    }\n\n    // Create internal table for storing internal data like flush timestamps\n    if (!db.objectStoreNames.contains(TABLE_NAMES.INTERNAL)) {\n      db.createObjectStore(TABLE_NAMES.INTERNAL, { keyPath: 'key' });\n    }\n  }\n\n  async setTags(tags: Record<string, string>): Promise<void> {\n    try {\n      if (Object.entries(tags).length === 0) {\n        return;\n      }\n\n      const db = await this.getDB();\n      const transaction = db.transaction([TABLE_NAMES.TAGS], 'readwrite');\n      const store = transaction.objectStore(TABLE_NAMES.TAGS);\n\n      return new Promise((resolve) => {\n        const entries = Object.entries(tags);\n\n        transaction.oncomplete = () => {\n          resolve();\n        };\n\n        transaction.onabort = (event) => {\n          this.logger.debug('DiagnosticsStorage: Failed to set tags', event);\n          resolve();\n        };\n\n        entries.forEach(([key, value]) => {\n          const putRequest = store.put({ key, value });\n\n          putRequest.onerror = (event) => {\n            this.logger.debug('DiagnosticsStorage: Failed to set tag', key, value, event);\n          };\n        });\n      });\n    } catch (error) {\n      this.logger.debug('DiagnosticsStorage: Failed to set tags', error);\n    }\n  }\n\n  async incrementCounters(counters: Record<string, number>): Promise<void> {\n    try {\n      if (Object.entries(counters).length === 0) {\n        return;\n      }\n\n      const db = await this.getDB();\n      const transaction = db.transaction([TABLE_NAMES.COUNTERS], 'readwrite');\n      const store = transaction.objectStore(TABLE_NAMES.COUNTERS);\n\n      return new Promise((resolve) => {\n        const entries = Object.entries(counters);\n\n        transaction.oncomplete = () => {\n          resolve();\n        };\n\n        transaction.onabort = (event) => {\n          this.logger.debug('DiagnosticsStorage: Failed to increment counters', event);\n          resolve();\n        };\n\n        // Read existing values and update them\n        entries.forEach(([key, incrementValue]) => {\n          const getRequest = store.get(key);\n\n          getRequest.onsuccess = () => {\n            const existingRecord = getRequest.result as CounterRecord | undefined;\n            /* istanbul ignore next */\n            const existingValue = existingRecord ? existingRecord.value : 0;\n            const putRequest = store.put({ key, value: existingValue + incrementValue });\n\n            putRequest.onerror = (event) => {\n              this.logger.debug('DiagnosticsStorage: Failed to update counter', key, event);\n            };\n          };\n\n          getRequest.onerror = (event) => {\n            this.logger.debug('DiagnosticsStorage: Failed to read existing counter', key, event);\n          };\n        });\n      });\n    } catch (error) {\n      this.logger.debug('DiagnosticsStorage: Failed to increment counters', error);\n    }\n  }\n\n  async setHistogramStats(histogramStats: Record<string, HistogramStats>): Promise<void> {\n    try {\n      if (Object.entries(histogramStats).length === 0) {\n        return;\n      }\n\n      const db = await this.getDB();\n      const transaction = db.transaction([TABLE_NAMES.HISTOGRAMS], 'readwrite');\n      const store = transaction.objectStore(TABLE_NAMES.HISTOGRAMS);\n\n      return new Promise((resolve) => {\n        const entries = Object.entries(histogramStats);\n\n        transaction.oncomplete = () => {\n          resolve();\n        };\n\n        transaction.onabort = (event) => {\n          this.logger.debug('DiagnosticsStorage: Failed to set histogram stats', event);\n          resolve();\n        };\n\n        // Read existing values and update them\n        entries.forEach(([key, newStats]) => {\n          const getRequest = store.get(key);\n\n          getRequest.onsuccess = () => {\n            const existingRecord = getRequest.result as HistogramRecord | undefined;\n            let updatedStats: HistogramRecord;\n\n            /* istanbul ignore next */\n            if (existingRecord) {\n              // Accumulate with existing stats\n              updatedStats = {\n                key,\n                count: existingRecord.count + newStats.count,\n                min: Math.min(existingRecord.min, newStats.min),\n                max: Math.max(existingRecord.max, newStats.max),\n                sum: existingRecord.sum + newStats.sum,\n              };\n            } else {\n              // Create new stats\n              updatedStats = {\n                key,\n                count: newStats.count,\n                min: newStats.min,\n                max: newStats.max,\n                sum: newStats.sum,\n              };\n            }\n\n            const putRequest = store.put(updatedStats);\n\n            putRequest.onerror = (event) => {\n              this.logger.debug('DiagnosticsStorage: Failed to set histogram stats', key, event);\n            };\n          };\n\n          getRequest.onerror = (event) => {\n            this.logger.debug('DiagnosticsStorage: Failed to read existing histogram stats', key, event);\n          };\n        });\n      });\n    } catch (error) {\n      this.logger.debug('DiagnosticsStorage: Failed to set histogram stats', error);\n    }\n  }\n\n  async addEventRecords(\n    events: Array<{ event_name: string; time: number; event_properties: Record<string, any> }>,\n  ): Promise<void> {\n    try {\n      if (events.length === 0) {\n        return;\n      }\n\n      const db = await this.getDB();\n      const transaction = db.transaction([TABLE_NAMES.EVENTS], 'readwrite');\n      const store = transaction.objectStore(TABLE_NAMES.EVENTS);\n\n      return new Promise((resolve) => {\n        transaction.oncomplete = () => {\n          resolve();\n        };\n\n        /* istanbul ignore next */\n        transaction.onabort = (event) => {\n          this.logger.debug('DiagnosticsStorage: Failed to add event records', event);\n          resolve();\n        };\n\n        // First, check how many events are currently stored\n        const countRequest = store.count();\n\n        countRequest.onsuccess = () => {\n          const currentCount = countRequest.result;\n\n          // Calculate how many events we can add\n          const availableSlots = Math.max(0, MAX_PERSISTENT_STORAGE_EVENTS_COUNT - currentCount);\n\n          if (availableSlots < events.length) {\n            this.logger.debug(\n              `DiagnosticsStorage: Only added ${availableSlots} of ${events.length} events due to storage limit`,\n            );\n          }\n\n          // Only add events up to the available slots (take the least recent ones)\n          events.slice(0, availableSlots).forEach((event) => {\n            const request = store.add(event);\n\n            request.onerror = (event) => {\n              this.logger.debug('DiagnosticsStorage: Failed to add event record', event);\n            };\n          });\n        };\n\n        countRequest.onerror = (event) => {\n          this.logger.debug('DiagnosticsStorage: Failed to count existing events', event);\n        };\n      });\n    } catch (error) {\n      this.logger.debug('DiagnosticsStorage: Failed to add event records', error);\n    }\n  }\n\n  async setInternal(key: string, value: string): Promise<void> {\n    try {\n      const db = await this.getDB();\n      const transaction = db.transaction([TABLE_NAMES.INTERNAL], 'readwrite');\n      const store = transaction.objectStore(TABLE_NAMES.INTERNAL);\n\n      return new Promise((resolve, reject) => {\n        /* istanbul ignore next */\n        transaction.onabort = () => reject(new Error('Failed to set internal value'));\n\n        const request = store.put({ key, value });\n\n        request.onsuccess = () => resolve();\n\n        /* istanbul ignore next */\n        request.onerror = () => reject(new Error('Failed to set internal value'));\n      });\n    } catch (error) {\n      /* istanbul ignore next */\n      this.logger.debug('DiagnosticsStorage: Failed to set internal value', error);\n    }\n  }\n\n  async getInternal(key: string): Promise<InternalRecord | undefined> {\n    try {\n      const db = await this.getDB();\n      const transaction = db.transaction([TABLE_NAMES.INTERNAL], 'readonly');\n      const store = transaction.objectStore(TABLE_NAMES.INTERNAL);\n\n      return new Promise((resolve, reject) => {\n        /* istanbul ignore next */\n        transaction.onabort = () => reject(new Error('Failed to get internal value'));\n\n        const request = store.get(key);\n\n        request.onsuccess = () => resolve(request.result as InternalRecord | undefined);\n\n        /* istanbul ignore next */\n        request.onerror = () => reject(new Error('Failed to get internal value'));\n      });\n    } catch (error) {\n      this.logger.debug('DiagnosticsStorage: Failed to get internal value', error);\n      return undefined;\n    }\n  }\n\n  async getLastFlushTimestamp(): Promise<number | undefined> {\n    try {\n      const record = await this.getInternal(INTERNAL_KEYS.LAST_FLUSH_TIMESTAMP);\n      return record ? parseInt(record.value, 10) : undefined;\n    } catch (error) {\n      /* istanbul ignore next */\n      this.logger.debug('DiagnosticsStorage: Failed to get last flush timestamp', error);\n      /* istanbul ignore next */\n      return undefined;\n    }\n  }\n\n  async setLastFlushTimestamp(timestamp: number): Promise<void> {\n    try {\n      await this.setInternal(INTERNAL_KEYS.LAST_FLUSH_TIMESTAMP, timestamp.toString());\n    } catch (error) {\n      /* istanbul ignore next */\n      this.logger.debug('DiagnosticsStorage: Failed to set last flush timestamp', error);\n    }\n  }\n\n  /* istanbul ignore next */\n  clearTable(transaction: IDBTransaction, tableName: string): Promise<void> {\n    return new Promise((resolve, reject) => {\n      const store = transaction.objectStore(tableName);\n      const request = store.clear();\n\n      request.onsuccess = () => resolve();\n      request.onerror = () => reject(new Error(`Failed to clear table ${tableName}`));\n    });\n  }\n\n  /* istanbul ignore next */\n  async getAllAndClear(): Promise<{\n    tags: TagRecord[];\n    counters: CounterRecord[];\n    histogramStats: HistogramRecord[];\n    events: EventRecord[];\n  }> {\n    try {\n      const db = await this.getDB();\n      const transaction = db.transaction(\n        [TABLE_NAMES.TAGS, TABLE_NAMES.COUNTERS, TABLE_NAMES.HISTOGRAMS, TABLE_NAMES.EVENTS],\n        'readwrite',\n      );\n\n      // Get all data first\n      const [tags, counters, histogramStats, events] = await Promise.all([\n        this.getAllFromStore<TagRecord>(transaction, TABLE_NAMES.TAGS),\n        this.getAllFromStore<CounterRecord>(transaction, TABLE_NAMES.COUNTERS),\n        this.getAllFromStore<HistogramRecord>(transaction, TABLE_NAMES.HISTOGRAMS),\n        this.getAllFromStore<EventRecord>(transaction, TABLE_NAMES.EVENTS),\n      ]);\n\n      // Clear all data in the same transaction\n      await Promise.all([\n        this.clearTable(transaction, TABLE_NAMES.COUNTERS),\n        this.clearTable(transaction, TABLE_NAMES.HISTOGRAMS),\n        this.clearTable(transaction, TABLE_NAMES.EVENTS),\n      ]);\n\n      return { tags, counters, histogramStats, events };\n    } catch (error) {\n      this.logger.debug('DiagnosticsStorage: Failed to get all and clear data', error);\n      return { tags: [], counters: [], histogramStats: [], events: [] };\n    }\n  }\n\n  /**\n   * Helper method to get all records from a store within a transaction\n   */\n  /* istanbul ignore next */\n  private getAllFromStore<T>(transaction: IDBTransaction, tableName: string): Promise<T[]> {\n    return new Promise((resolve, reject) => {\n      const store = transaction.objectStore(tableName);\n      const request = store.getAll();\n\n      request.onsuccess = () => resolve(request.result as T[]);\n      request.onerror = () => reject(new Error(`Failed to get all from ${tableName}`));\n    });\n  }\n}\n"]}