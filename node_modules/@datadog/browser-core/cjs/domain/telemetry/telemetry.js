"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getTelemetryObservable = getTelemetryObservable;
exports.startTelemetry = startTelemetry;
exports.startTelemetryCollection = startTelemetryCollection;
exports.resetTelemetry = resetTelemetry;
exports.addTelemetryDebug = addTelemetryDebug;
exports.addTelemetryError = addTelemetryError;
exports.addTelemetryConfiguration = addTelemetryConfiguration;
exports.addTelemetryMetrics = addTelemetryMetrics;
exports.addTelemetryUsage = addTelemetryUsage;
exports.formatError = formatError;
exports.scrubCustomerFrames = scrubCustomerFrames;
const display_1 = require("../../tools/display");
const error_1 = require("../error/error");
const handlingStack_1 = require("../../tools/stackTrace/handlingStack");
const experimentalFeatures_1 = require("../../tools/experimentalFeatures");
const tags_1 = require("../tags");
const intakeSites_1 = require("../intakeSites");
const observable_1 = require("../../tools/observable");
const timeUtils_1 = require("../../tools/utils/timeUtils");
const monitor_1 = require("../../tools/monitor");
const sendToExtension_1 = require("../../tools/sendToExtension");
const numberUtils_1 = require("../../tools/utils/numberUtils");
const jsonStringify_1 = require("../../tools/serialisation/jsonStringify");
const mergeInto_1 = require("../../tools/mergeInto");
const computeStackTrace_1 = require("../../tools/stackTrace/computeStackTrace");
const connectivity_1 = require("../connectivity");
const transport_1 = require("../../transport");
const abstractHooks_1 = require("../../tools/abstractHooks");
const globalObject_1 = require("../../tools/globalObject");
const rawTelemetryEvent_types_1 = require("./rawTelemetryEvent.types");
const ALLOWED_FRAME_URLS = [
    'https://www.datadoghq-browser-agent.com',
    'https://www.datad0g-browser-agent.com',
    'https://d3uc069fcn7uxw.cloudfront.net',
    'https://d20xtzwzcl0ceb.cloudfront.net',
    'http://localhost',
    '<anonymous>',
];
const METRIC_SAMPLE_RATE = 1;
const TELEMETRY_EXCLUDED_SITES = [intakeSites_1.INTAKE_SITE_US1_FED];
let telemetryObservable;
function getTelemetryObservable() {
    if (!telemetryObservable) {
        telemetryObservable = new observable_1.BufferedObservable(100);
    }
    return telemetryObservable;
}
function startTelemetry(telemetryService, configuration, hooks, reportError, pageMayExitObservable, createEncoder) {
    const observable = new observable_1.Observable();
    const { stop } = startTelemetryTransport(configuration, reportError, pageMayExitObservable, createEncoder, observable);
    const { enabled, metricsEnabled } = startTelemetryCollection(telemetryService, configuration, hooks, observable);
    return {
        stop,
        enabled,
        metricsEnabled,
    };
}
function startTelemetryCollection(telemetryService, configuration, hooks, observable, metricSampleRate = METRIC_SAMPLE_RATE) {
    const alreadySentEventsByKind = {};
    const telemetryEnabled = !TELEMETRY_EXCLUDED_SITES.includes(configuration.site) && (0, numberUtils_1.performDraw)(configuration.telemetrySampleRate);
    const telemetryEnabledPerType = {
        [rawTelemetryEvent_types_1.TelemetryType.LOG]: telemetryEnabled,
        [rawTelemetryEvent_types_1.TelemetryType.CONFIGURATION]: telemetryEnabled && (0, numberUtils_1.performDraw)(configuration.telemetryConfigurationSampleRate),
        [rawTelemetryEvent_types_1.TelemetryType.USAGE]: telemetryEnabled && (0, numberUtils_1.performDraw)(configuration.telemetryUsageSampleRate),
        // not an actual "type" but using a single draw for all metrics
        metric: telemetryEnabled && (0, numberUtils_1.performDraw)(metricSampleRate),
    };
    const runtimeEnvInfo = getRuntimeEnvInfo();
    const telemetryObservable = getTelemetryObservable();
    telemetryObservable.subscribe(({ rawEvent, metricName }) => {
        if ((metricName && !telemetryEnabledPerType['metric']) || !telemetryEnabledPerType[rawEvent.type]) {
            return;
        }
        const kind = metricName || rawEvent.status || rawEvent.type;
        let alreadySentEvents = alreadySentEventsByKind[kind];
        if (!alreadySentEvents) {
            alreadySentEvents = alreadySentEventsByKind[kind] = new Set();
        }
        if (alreadySentEvents.size >= configuration.maxTelemetryEventsPerPage) {
            return;
        }
        const stringifiedEvent = (0, jsonStringify_1.jsonStringify)(rawEvent);
        if (alreadySentEvents.has(stringifiedEvent)) {
            return;
        }
        const defaultTelemetryEventAttributes = hooks.triggerHook(1 /* HookNames.AssembleTelemetry */, {
            startTime: (0, timeUtils_1.clocksNow)().relative,
        });
        if (defaultTelemetryEventAttributes === abstractHooks_1.DISCARDED) {
            return;
        }
        const event = toTelemetryEvent(defaultTelemetryEventAttributes, telemetryService, rawEvent, runtimeEnvInfo);
        observable.notify(event);
        (0, sendToExtension_1.sendToExtension)('telemetry', event);
        alreadySentEvents.add(stringifiedEvent);
    });
    telemetryObservable.unbuffer();
    (0, monitor_1.startMonitorErrorCollection)(addTelemetryError);
    return {
        enabled: telemetryEnabled,
        metricsEnabled: telemetryEnabledPerType['metric'],
    };
    function toTelemetryEvent(defaultTelemetryEventAttributes, telemetryService, rawEvent, runtimeEnvInfo) {
        const clockNow = (0, timeUtils_1.clocksNow)();
        const event = {
            type: 'telemetry',
            date: clockNow.timeStamp,
            service: telemetryService,
            version: "6.22.0",
            source: 'browser',
            _dd: {
                format_version: 2,
            },
            telemetry: (0, mergeInto_1.combine)(rawEvent, {
                runtime_env: runtimeEnvInfo,
                connectivity: (0, connectivity_1.getConnectivity)(),
                sdk_setup: "npm",
            }),
            ddtags: (0, tags_1.buildTags)(configuration).join(','),
            experimental_features: Array.from((0, experimentalFeatures_1.getExperimentalFeatures)()),
        };
        return (0, mergeInto_1.combine)(event, defaultTelemetryEventAttributes);
    }
}
function startTelemetryTransport(configuration, reportError, pageMayExitObservable, createEncoder, telemetryObservable) {
    const cleanupTasks = [];
    if ((0, transport_1.canUseEventBridge)()) {
        const bridge = (0, transport_1.getEventBridge)();
        const telemetrySubscription = telemetryObservable.subscribe((event) => bridge.send('internal_telemetry', event));
        cleanupTasks.push(telemetrySubscription.unsubscribe);
    }
    else {
        const endpoints = [configuration.rumEndpointBuilder];
        if (configuration.replica && isTelemetryReplicationAllowed(configuration)) {
            endpoints.push(configuration.replica.rumEndpointBuilder);
        }
        const telemetryBatch = (0, transport_1.createBatch)({
            encoder: createEncoder(4 /* DeflateEncoderStreamId.TELEMETRY */),
            request: (0, transport_1.createHttpRequest)(endpoints, configuration.batchBytesLimit, reportError),
            flushController: (0, transport_1.createFlushController)({
                messagesLimit: configuration.batchMessagesLimit,
                bytesLimit: configuration.batchBytesLimit,
                durationLimit: configuration.flushTimeout,
                pageMayExitObservable,
                // We don't use an actual session expire observable here, to make telemetry collection
                // independent of the session. This allows to start and send telemetry events earlier.
                sessionExpireObservable: new observable_1.Observable(),
            }),
            messageBytesLimit: configuration.messageBytesLimit,
        });
        cleanupTasks.push(telemetryBatch.stop);
        const telemetrySubscription = telemetryObservable.subscribe(telemetryBatch.add);
        cleanupTasks.push(telemetrySubscription.unsubscribe);
    }
    return {
        stop: () => cleanupTasks.forEach((task) => task()),
    };
}
function getRuntimeEnvInfo() {
    var _a;
    return {
        is_local_file: ((_a = globalObject_1.globalObject.location) === null || _a === void 0 ? void 0 : _a.protocol) === 'file:',
        is_worker: globalObject_1.isWorkerEnvironment,
    };
}
function resetTelemetry() {
    telemetryObservable = undefined;
}
/**
 * Avoid mixing telemetry events from different data centers
 * but keep replicating staging events for reliability
 */
function isTelemetryReplicationAllowed(configuration) {
    return configuration.site === intakeSites_1.INTAKE_SITE_STAGING;
}
function addTelemetryDebug(message, context) {
    (0, monitor_1.displayIfDebugEnabled)(display_1.ConsoleApiName.debug, message, context);
    getTelemetryObservable().notify({
        rawEvent: {
            type: rawTelemetryEvent_types_1.TelemetryType.LOG,
            message,
            status: "debug" /* StatusType.debug */,
            ...context,
        },
    });
}
function addTelemetryError(e, context) {
    getTelemetryObservable().notify({
        rawEvent: {
            type: rawTelemetryEvent_types_1.TelemetryType.LOG,
            status: "error" /* StatusType.error */,
            ...formatError(e),
            ...context,
        },
    });
}
function addTelemetryConfiguration(configuration) {
    getTelemetryObservable().notify({
        rawEvent: {
            type: rawTelemetryEvent_types_1.TelemetryType.CONFIGURATION,
            configuration,
        },
    });
}
function addTelemetryMetrics(metricName, context) {
    getTelemetryObservable().notify({
        rawEvent: {
            type: rawTelemetryEvent_types_1.TelemetryType.LOG,
            message: metricName,
            status: "debug" /* StatusType.debug */,
            ...context,
        },
        metricName,
    });
}
function addTelemetryUsage(usage) {
    getTelemetryObservable().notify({
        rawEvent: {
            type: rawTelemetryEvent_types_1.TelemetryType.USAGE,
            usage,
        },
    });
}
function formatError(e) {
    if ((0, error_1.isError)(e)) {
        const stackTrace = (0, computeStackTrace_1.computeStackTrace)(e);
        return {
            error: {
                kind: stackTrace.name,
                stack: (0, handlingStack_1.toStackTraceString)(scrubCustomerFrames(stackTrace)),
            },
            message: stackTrace.message,
        };
    }
    return {
        error: {
            stack: error_1.NO_ERROR_STACK_PRESENT_MESSAGE,
        },
        message: `${"Uncaught" /* NonErrorPrefix.UNCAUGHT */} ${(0, jsonStringify_1.jsonStringify)(e)}`,
    };
}
function scrubCustomerFrames(stackTrace) {
    stackTrace.stack = stackTrace.stack.filter((frame) => !frame.url || ALLOWED_FRAME_URLS.some((allowedFrameUrl) => frame.url.startsWith(allowedFrameUrl)));
    return stackTrace;
}
//# sourceMappingURL=telemetry.js.map