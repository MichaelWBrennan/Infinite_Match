import { addTelemetryDebug, createHttpRequest, jsonStringify, objectEntries } from '@datadog/browser-core';
export function createFormDataTransport(configuration, lifeCycle, createEncoder, streamId) {
    const reportError = (error) => {
        lifeCycle.notify(14 /* LifeCycleEventType.RAW_ERROR_COLLECTED */, { error });
        // monitor-until: forever, to keep an eye on the errors reported to customers
        addTelemetryDebug('Error reported to customer', { 'error.message': error.message });
    };
    const httpRequest = createHttpRequest([configuration.profilingEndpointBuilder], configuration.batchBytesLimit, reportError);
    const encoder = createEncoder(streamId);
    return {
        async send({ event, ...attachments }) {
            const formData = new FormData();
            const serializedEvent = jsonStringify(event);
            if (!serializedEvent) {
                throw new Error('Failed to serialize event');
            }
            formData.append('event', new Blob([serializedEvent], { type: 'application/json' }), 'event.json');
            let bytesCount = serializedEvent.length;
            for (const [key, value] of objectEntries(attachments)) {
                const serializedValue = jsonStringify(value);
                if (!serializedValue) {
                    throw new Error('Failed to serialize attachment');
                }
                const result = await encode(encoder, serializedValue);
                bytesCount += result.outputBytesCount;
                formData.append(key, new Blob([result.output]), key);
            }
            httpRequest.send({
                data: formData,
                bytesCount,
            });
        },
    };
}
function encode(encoder, data) {
    return new Promise((resolve) => {
        encoder.write(data);
        encoder.finish((encoderResult) => {
            resolve(encoderResult);
        });
    });
}
//# sourceMappingURL=formDataTransport.js.map