import { getType, isMatchOption, serializeConfiguration, DefaultPrivacyLevel, TraceContextInjection, display, objectHasValue, validateAndBuildConfiguration, isSampleRate, isNumber, isNonEmptyArray, } from '@datadog/browser-core';
import { isTracingOption } from '../tracing/tracer';
export const DEFAULT_PROPAGATOR_TYPES = ['tracecontext', 'datadog'];
export function validateAndBuildRumConfiguration(initConfiguration, errorStack) {
    var _a, _b, _c, _d, _e, _f, _g;
    if (initConfiguration.trackFeatureFlagsForEvents !== undefined &&
        !Array.isArray(initConfiguration.trackFeatureFlagsForEvents)) {
        display.warn('trackFeatureFlagsForEvents should be an array');
    }
    if (!initConfiguration.applicationId) {
        display.error('Application ID is not configured, no RUM data will be collected.');
        return;
    }
    if (!isSampleRate(initConfiguration.sessionReplaySampleRate, 'Session Replay') ||
        !isSampleRate(initConfiguration.traceSampleRate, 'Trace')) {
        return;
    }
    if (initConfiguration.excludedActivityUrls !== undefined && !Array.isArray(initConfiguration.excludedActivityUrls)) {
        display.error('Excluded Activity Urls should be an array');
        return;
    }
    const allowedTracingUrls = validateAndBuildTracingOptions(initConfiguration);
    if (!allowedTracingUrls) {
        return;
    }
    const baseConfiguration = validateAndBuildConfiguration(initConfiguration, errorStack);
    const allowedGraphQlUrls = validateAndBuildGraphQlOptions(initConfiguration);
    if (!baseConfiguration) {
        return;
    }
    const sessionReplaySampleRate = (_a = initConfiguration.sessionReplaySampleRate) !== null && _a !== void 0 ? _a : 0;
    return {
        applicationId: initConfiguration.applicationId,
        actionNameAttribute: initConfiguration.actionNameAttribute,
        sessionReplaySampleRate,
        startSessionReplayRecordingManually: initConfiguration.startSessionReplayRecordingManually !== undefined
            ? !!initConfiguration.startSessionReplayRecordingManually
            : sessionReplaySampleRate === 0,
        traceSampleRate: (_b = initConfiguration.traceSampleRate) !== null && _b !== void 0 ? _b : 100,
        rulePsr: isNumber(initConfiguration.traceSampleRate) ? initConfiguration.traceSampleRate / 100 : undefined,
        allowedTracingUrls,
        excludedActivityUrls: (_c = initConfiguration.excludedActivityUrls) !== null && _c !== void 0 ? _c : [],
        workerUrl: initConfiguration.workerUrl,
        compressIntakeRequests: !!initConfiguration.compressIntakeRequests,
        trackUserInteractions: !!((_d = initConfiguration.trackUserInteractions) !== null && _d !== void 0 ? _d : true),
        trackViewsManually: !!initConfiguration.trackViewsManually,
        trackResources: !!((_e = initConfiguration.trackResources) !== null && _e !== void 0 ? _e : true),
        trackLongTasks: !!((_f = initConfiguration.trackLongTasks) !== null && _f !== void 0 ? _f : true),
        trackBfcacheViews: !!initConfiguration.trackBfcacheViews,
        trackEarlyRequests: !!initConfiguration.trackEarlyRequests,
        subdomain: initConfiguration.subdomain,
        defaultPrivacyLevel: objectHasValue(DefaultPrivacyLevel, initConfiguration.defaultPrivacyLevel)
            ? initConfiguration.defaultPrivacyLevel
            : DefaultPrivacyLevel.MASK,
        enablePrivacyForActionName: !!initConfiguration.enablePrivacyForActionName,
        traceContextInjection: objectHasValue(TraceContextInjection, initConfiguration.traceContextInjection)
            ? initConfiguration.traceContextInjection
            : TraceContextInjection.SAMPLED,
        plugins: initConfiguration.plugins || [],
        trackFeatureFlagsForEvents: initConfiguration.trackFeatureFlagsForEvents || [],
        profilingSampleRate: (_g = initConfiguration.profilingSampleRate) !== null && _g !== void 0 ? _g : 0,
        propagateTraceBaggage: !!initConfiguration.propagateTraceBaggage,
        allowedGraphQlUrls,
        ...baseConfiguration,
    };
}
/**
 * Validates allowedTracingUrls and converts match options to tracing options
 */
function validateAndBuildTracingOptions(initConfiguration) {
    if (initConfiguration.allowedTracingUrls === undefined) {
        return [];
    }
    if (!Array.isArray(initConfiguration.allowedTracingUrls)) {
        display.error('Allowed Tracing URLs should be an array');
        return;
    }
    if (initConfiguration.allowedTracingUrls.length !== 0 && initConfiguration.service === undefined) {
        display.error('Service needs to be configured when tracing is enabled');
        return;
    }
    // Convert from (MatchOption | TracingOption) to TracingOption, remove unknown properties
    const tracingOptions = [];
    initConfiguration.allowedTracingUrls.forEach((option) => {
        if (isMatchOption(option)) {
            tracingOptions.push({ match: option, propagatorTypes: DEFAULT_PROPAGATOR_TYPES });
        }
        else if (isTracingOption(option)) {
            tracingOptions.push(option);
        }
        else {
            display.warn('Allowed Tracing Urls parameters should be a string, RegExp, function, or an object. Ignoring parameter', option);
        }
    });
    return tracingOptions;
}
/**
 * Combines the selected tracing propagators from the different options in allowedTracingUrls
 */
function getSelectedTracingPropagators(configuration) {
    const usedTracingPropagators = new Set();
    if (isNonEmptyArray(configuration.allowedTracingUrls)) {
        configuration.allowedTracingUrls.forEach((option) => {
            if (isMatchOption(option)) {
                DEFAULT_PROPAGATOR_TYPES.forEach((propagatorType) => usedTracingPropagators.add(propagatorType));
            }
            else if (getType(option) === 'object' && Array.isArray(option.propagatorTypes)) {
                // Ensure we have an array, as we cannot rely on types yet (configuration is provided by users)
                option.propagatorTypes.forEach((propagatorType) => usedTracingPropagators.add(propagatorType));
            }
        });
    }
    return Array.from(usedTracingPropagators);
}
/**
 * Build GraphQL options from configuration
 */
function validateAndBuildGraphQlOptions(initConfiguration) {
    if (!initConfiguration.allowedGraphQlUrls) {
        return [];
    }
    if (!Array.isArray(initConfiguration.allowedGraphQlUrls)) {
        display.warn('allowedGraphQlUrls should be an array');
        return [];
    }
    const graphQlOptions = [];
    initConfiguration.allowedGraphQlUrls.forEach((option) => {
        if (isMatchOption(option)) {
            graphQlOptions.push({ match: option, trackPayload: false });
        }
        else if (option && typeof option === 'object' && 'match' in option && isMatchOption(option.match)) {
            graphQlOptions.push({
                match: option.match,
                trackPayload: !!option.trackPayload,
            });
        }
    });
    return graphQlOptions;
}
function hasGraphQlPayloadTracking(allowedGraphQlUrls) {
    return (isNonEmptyArray(allowedGraphQlUrls) &&
        allowedGraphQlUrls.some((option) => {
            if (typeof option === 'object' && 'trackPayload' in option) {
                return !!option.trackPayload;
            }
            return false;
        }));
}
export function serializeRumConfiguration(configuration) {
    var _a;
    const baseSerializedConfiguration = serializeConfiguration(configuration);
    return {
        session_replay_sample_rate: configuration.sessionReplaySampleRate,
        start_session_replay_recording_manually: configuration.startSessionReplayRecordingManually,
        trace_sample_rate: configuration.traceSampleRate,
        trace_context_injection: configuration.traceContextInjection,
        propagate_trace_baggage: configuration.propagateTraceBaggage,
        action_name_attribute: configuration.actionNameAttribute,
        use_allowed_tracing_urls: isNonEmptyArray(configuration.allowedTracingUrls),
        use_allowed_graph_ql_urls: isNonEmptyArray(configuration.allowedGraphQlUrls),
        use_track_graph_ql_payload: hasGraphQlPayloadTracking(configuration.allowedGraphQlUrls),
        selected_tracing_propagators: getSelectedTracingPropagators(configuration),
        default_privacy_level: configuration.defaultPrivacyLevel,
        enable_privacy_for_action_name: configuration.enablePrivacyForActionName,
        use_excluded_activity_urls: isNonEmptyArray(configuration.excludedActivityUrls),
        use_worker_url: !!configuration.workerUrl,
        compress_intake_requests: configuration.compressIntakeRequests,
        track_views_manually: configuration.trackViewsManually,
        track_user_interactions: configuration.trackUserInteractions,
        track_resources: configuration.trackResources,
        track_long_task: configuration.trackLongTasks,
        track_bfcache_views: configuration.trackBfcacheViews,
        track_early_requests: configuration.trackEarlyRequests,
        plugins: (_a = configuration.plugins) === null || _a === void 0 ? void 0 : _a.map((plugin) => {
            var _a;
            return ({
                name: plugin.name,
                ...(_a = plugin.getConfigurationTelemetry) === null || _a === void 0 ? void 0 : _a.call(plugin),
            });
        }),
        track_feature_flags_for_events: configuration.trackFeatureFlagsForEvents,
        remote_configuration_id: configuration.remoteConfigurationId,
        profiling_sample_rate: configuration.profilingSampleRate,
        use_remote_configuration_proxy: !!configuration.remoteConfigurationProxy,
        ...baseSerializedConfiguration,
    };
}
//# sourceMappingURL=configuration.js.map