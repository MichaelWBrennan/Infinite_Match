/**
 * Terminology inspired from https://www.rfc-editor.org/rfc/rfc9535.html
 *
 * jsonpath-query      = segment*
 * segment             = .name-shorthand / bracketed-selection
 * bracketed-selection = ['name-selector'] / ["name-selector"] / [index-selector]
 *
 * Useful references:
 * - https://goessner.net/articles/JsonPath/
 * - https://jsonpath.com/
 * - https://github.com/jsonpath-standard
 */
/**
 * Extract selectors from a simple JSON path expression, return [] for an invalid path
 *
 * Supports:
 * - Dot notation: `foo.bar.baz`
 * - Bracket notation: `['foo']["bar"]`
 * - Array indices: `items[0]`, `data['users'][1]`
 *
 * Examples:
 * parseJsonPath("['foo'].bar[12]")
 * => ['foo', 'bar', '12']
 *
 * parseJsonPath("['foo")
 * => []
 */
export function parseJsonPath(path) {
    const selectors = [];
    let previousToken = 0 /* Token.START */;
    let currentToken;
    const parsingContext = { quote: undefined, escapeSequence: undefined };
    let currentSelector = '';
    for (const char of path) {
        // find which kind of token is this char
        currentToken = ALLOWED_NEXT_TOKENS[previousToken].find((token) => TOKEN_PREDICATE[token](char, parsingContext));
        if (!currentToken) {
            return [];
        }
        if (parsingContext.escapeSequence !== undefined && currentToken !== 12 /* Token.ESCAPE_SEQUENCE_CHAR */) {
            if (!isValidEscapeSequence(parsingContext.escapeSequence)) {
                return [];
            }
            currentSelector += resolveEscapeSequence(parsingContext.escapeSequence);
            parsingContext.escapeSequence = undefined;
        }
        if (ALLOWED_SELECTOR_TOKENS.includes(currentToken)) {
            // buffer the char if it belongs to the selector
            // ex: foo['bar']
            //      ^    ^
            currentSelector += char;
        }
        else if (ALLOWED_SELECTOR_DELIMITER_TOKENS.includes(currentToken) && currentSelector !== '') {
            // close the current path part if we have reach a path part delimiter
            // ex: foo.bar['qux']
            //        ^   ^     ^
            selectors.push(currentSelector);
            currentSelector = '';
        }
        else if (currentToken === 12 /* Token.ESCAPE_SEQUENCE_CHAR */) {
            parsingContext.escapeSequence = parsingContext.escapeSequence ? `${parsingContext.escapeSequence}${char}` : char;
        }
        else if (currentToken === 8 /* Token.QUOTE_START */) {
            parsingContext.quote = char;
        }
        else if (currentToken === 9 /* Token.QUOTE_END */) {
            parsingContext.quote = undefined;
        }
        previousToken = currentToken;
    }
    if (!ALLOWED_NEXT_TOKENS[previousToken].includes(1 /* Token.END */)) {
        return [];
    }
    if (currentSelector !== '') {
        selectors.push(currentSelector);
    }
    return selectors;
}
const NAME_SHORTHAND_FIRST_CHAR_REGEX = /[a-zA-Z_$]/;
const NAME_SHORTHAND_CHAR_REGEX = /[a-zA-Z0-9_$]/;
const DIGIT_REGEX = /[0-9]/;
const UNICODE_CHAR_REGEX = /[a-fA-F0-9]/;
const QUOTE_CHARS = '\'"';
const TOKEN_PREDICATE = {
    // no char should match to START or END
    [0 /* Token.START */]: () => false,
    [1 /* Token.END */]: () => false,
    [2 /* Token.NAME_SHORTHAND_FIRST_CHAR */]: (char) => NAME_SHORTHAND_FIRST_CHAR_REGEX.test(char),
    [3 /* Token.NAME_SHORTHAND_CHAR */]: (char) => NAME_SHORTHAND_CHAR_REGEX.test(char),
    [4 /* Token.DOT */]: (char) => char === '.',
    [5 /* Token.BRACKET_START */]: (char) => char === '[',
    [6 /* Token.BRACKET_END */]: (char) => char === ']',
    [7 /* Token.DIGIT */]: (char) => DIGIT_REGEX.test(char),
    [8 /* Token.QUOTE_START */]: (char) => QUOTE_CHARS.includes(char),
    [9 /* Token.QUOTE_END */]: (char, parsingContext) => char === parsingContext.quote,
    [10 /* Token.NAME_SELECTOR_CHAR */]: () => true, // any char can be used in name selector
    [11 /* Token.ESCAPE */]: (char) => char === '\\',
    [12 /* Token.ESCAPE_SEQUENCE_CHAR */]: (char, parsingContext) => {
        if (parsingContext.escapeSequence === undefined) {
            // see https://www.rfc-editor.org/rfc/rfc9535.html#name-semantics-3
            return `${parsingContext.quote}/\\bfnrtu`.includes(char);
        }
        else if (parsingContext.escapeSequence.startsWith('u') && parsingContext.escapeSequence.length < 5) {
            return UNICODE_CHAR_REGEX.test(char);
        }
        return false;
    },
};
const ALLOWED_NEXT_TOKENS = {
    [0 /* Token.START */]: [2 /* Token.NAME_SHORTHAND_FIRST_CHAR */, 5 /* Token.BRACKET_START */],
    [1 /* Token.END */]: [],
    [2 /* Token.NAME_SHORTHAND_FIRST_CHAR */]: [3 /* Token.NAME_SHORTHAND_CHAR */, 4 /* Token.DOT */, 5 /* Token.BRACKET_START */, 1 /* Token.END */],
    [3 /* Token.NAME_SHORTHAND_CHAR */]: [3 /* Token.NAME_SHORTHAND_CHAR */, 4 /* Token.DOT */, 5 /* Token.BRACKET_START */, 1 /* Token.END */],
    [4 /* Token.DOT */]: [2 /* Token.NAME_SHORTHAND_FIRST_CHAR */],
    [5 /* Token.BRACKET_START */]: [8 /* Token.QUOTE_START */, 7 /* Token.DIGIT */],
    [6 /* Token.BRACKET_END */]: [4 /* Token.DOT */, 5 /* Token.BRACKET_START */, 1 /* Token.END */],
    [7 /* Token.DIGIT */]: [7 /* Token.DIGIT */, 6 /* Token.BRACKET_END */],
    [8 /* Token.QUOTE_START */]: [11 /* Token.ESCAPE */, 9 /* Token.QUOTE_END */, 10 /* Token.NAME_SELECTOR_CHAR */],
    [9 /* Token.QUOTE_END */]: [6 /* Token.BRACKET_END */],
    [10 /* Token.NAME_SELECTOR_CHAR */]: [11 /* Token.ESCAPE */, 9 /* Token.QUOTE_END */, 10 /* Token.NAME_SELECTOR_CHAR */],
    [11 /* Token.ESCAPE */]: [12 /* Token.ESCAPE_SEQUENCE_CHAR */],
    [12 /* Token.ESCAPE_SEQUENCE_CHAR */]: [12 /* Token.ESCAPE_SEQUENCE_CHAR */, 11 /* Token.ESCAPE */, 9 /* Token.QUOTE_END */, 10 /* Token.NAME_SELECTOR_CHAR */],
};
// foo['bar\n'][12]
// ^^    ^ ^^   ^
const ALLOWED_SELECTOR_TOKENS = [
    2 /* Token.NAME_SHORTHAND_FIRST_CHAR */,
    3 /* Token.NAME_SHORTHAND_CHAR */,
    7 /* Token.DIGIT */,
    10 /* Token.NAME_SELECTOR_CHAR */,
];
// foo.bar['qux']
//    ^   ^     ^
const ALLOWED_SELECTOR_DELIMITER_TOKENS = [4 /* Token.DOT */, 5 /* Token.BRACKET_START */, 6 /* Token.BRACKET_END */];
function isValidEscapeSequence(escapeSequence) {
    return '"\'/\\bfnrt'.includes(escapeSequence) || (escapeSequence.startsWith('u') && escapeSequence.length === 5);
}
const ESCAPED_CHARS = {
    '"': '"',
    "'": "'",
    '/': '/',
    '\\': '\\',
    b: '\b',
    f: '\f',
    n: '\n',
    r: '\r',
    t: '\t',
};
function resolveEscapeSequence(escapeSequence) {
    if (escapeSequence.startsWith('u')) {
        // build Unicode char from code
        return String.fromCharCode(parseInt(escapeSequence.slice(1), 16));
    }
    return ESCAPED_CHARS[escapeSequence];
}
//# sourceMappingURL=jsonPathParser.js.map