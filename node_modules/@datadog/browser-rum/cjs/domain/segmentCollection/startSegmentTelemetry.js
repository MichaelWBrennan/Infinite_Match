"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.startSegmentTelemetry = startSegmentTelemetry;
const browser_core_1 = require("@datadog/browser-core");
function startSegmentTelemetry(telemetry, requestObservable) {
    if (!telemetry.metricsEnabled) {
        return { stop: browser_core_1.noop };
    }
    const { unsubscribe } = requestObservable.subscribe((requestEvent) => {
        if (requestEvent.type === 'failure' ||
            requestEvent.type === 'queue-full' ||
            (requestEvent.type === 'success' && requestEvent.payload.isFullSnapshot)) {
            const metrics = createSegmentMetrics(requestEvent.type, requestEvent.bandwidth, requestEvent.payload);
            // monitor-until: 2026-07-01
            (0, browser_core_1.addTelemetryMetrics)("Segment network request metrics" /* TelemetryMetrics.SEGMENT_METRICS_TELEMETRY_NAME */, { metrics });
        }
    });
    return {
        stop: unsubscribe,
    };
}
function createSegmentMetrics(result, bandwidthStats, payload) {
    return {
        cssText: {
            count: payload.cssText.count,
            max: payload.cssText.max,
            sum: payload.cssText.sum,
        },
        isFullSnapshot: payload.isFullSnapshot,
        ongoingRequests: {
            count: bandwidthStats.ongoingRequestCount,
            totalSize: bandwidthStats.ongoingByteCount,
        },
        recordCount: payload.recordCount,
        result,
        serializationDuration: {
            count: payload.serializationDuration.count,
            max: payload.serializationDuration.max,
            sum: payload.serializationDuration.sum,
        },
        size: {
            compressed: payload.bytesCount,
            raw: payload.rawSize,
        },
    };
}
//# sourceMappingURL=startSegmentTelemetry.js.map