import { reducePrivacyLevel, getNodeSelfPrivacyLevel, getTextContent, isNodeShadowRoot, hasChildNodes, forEachChildNodes, NodePrivacyLevel, PRIVACY_ATTR_NAME, PRIVACY_ATTR_VALUE_HIDDEN, } from '@datadog/browser-rum-core';
import { NodeType } from '../../../types';
import { getValidTagName } from './serializationUtils';
import { serializeStyleSheets } from './serializeStyleSheets';
import { serializeAttributes } from './serializeAttributes';
export function serializeNodeWithId(node, parentNodePrivacyLevel, options) {
    const serializedNode = serializeNode(node, parentNodePrivacyLevel, options);
    if (!serializedNode) {
        return null;
    }
    const id = options.scope.nodeIds.assign(node);
    const serializedNodeWithId = serializedNode;
    serializedNodeWithId.id = id;
    if (options.serializedNodeIds) {
        options.serializedNodeIds.add(id);
    }
    return serializedNodeWithId;
}
export function serializeChildNodes(node, parentNodePrivacyLevel, options) {
    const result = [];
    forEachChildNodes(node, (childNode) => {
        const serializedChildNode = serializeNodeWithId(childNode, parentNodePrivacyLevel, options);
        if (serializedChildNode) {
            result.push(serializedChildNode);
        }
    });
    return result;
}
function serializeNode(node, parentNodePrivacyLevel, options) {
    switch (node.nodeType) {
        case node.DOCUMENT_NODE:
            return serializeDocumentNode(node, parentNodePrivacyLevel, options);
        case node.DOCUMENT_FRAGMENT_NODE:
            return serializeDocumentFragmentNode(node, parentNodePrivacyLevel, options);
        case node.DOCUMENT_TYPE_NODE:
            return serializeDocumentTypeNode(node);
        case node.ELEMENT_NODE:
            return serializeElementNode(node, parentNodePrivacyLevel, options);
        case node.TEXT_NODE:
            return serializeTextNode(node, parentNodePrivacyLevel);
        case node.CDATA_SECTION_NODE:
            return serializeCDataNode();
    }
}
export function serializeDocumentNode(document, parentNodePrivacyLevel, options) {
    return {
        type: NodeType.Document,
        childNodes: serializeChildNodes(document, parentNodePrivacyLevel, options),
        adoptedStyleSheets: serializeStyleSheets(document.adoptedStyleSheets),
    };
}
function serializeDocumentFragmentNode(element, parentNodePrivacyLevel, options) {
    const isShadowRoot = isNodeShadowRoot(element);
    if (isShadowRoot) {
        options.serializationContext.shadowRootsController.addShadowRoot(element);
    }
    return {
        type: NodeType.DocumentFragment,
        childNodes: serializeChildNodes(element, parentNodePrivacyLevel, options),
        isShadowRoot,
        adoptedStyleSheets: isShadowRoot ? serializeStyleSheets(element.adoptedStyleSheets) : undefined,
    };
}
function serializeDocumentTypeNode(documentType) {
    return {
        type: NodeType.DocumentType,
        name: documentType.name,
        publicId: documentType.publicId,
        systemId: documentType.systemId,
    };
}
/**
 * Serializing Element nodes involves capturing:
 * 1. HTML ATTRIBUTES:
 * 2. JS STATE:
 * - scroll offsets
 * - Form fields (input value, checkbox checked, option selection, range)
 * - Canvas state,
 * - Media (video/audio) play mode + currentTime
 * - iframe contents
 * - webcomponents
 * 3. CUSTOM PROPERTIES:
 * - height+width for when `hidden` to cover the element
 * 4. EXCLUDED INTERACTION STATE:
 * - focus (possible, but not worth perf impact)
 * - hover (tracked only via mouse activity)
 * - fullscreen mode
 */
function serializeElementNode(element, parentNodePrivacyLevel, options) {
    const tagName = getValidTagName(element.tagName);
    const isSVG = isSVGElement(element) || undefined;
    // For performance reason, we don't use getNodePrivacyLevel directly: we leverage the
    // parentNodePrivacyLevel option to avoid iterating over all parents
    const nodePrivacyLevel = reducePrivacyLevel(getNodeSelfPrivacyLevel(element), parentNodePrivacyLevel);
    if (nodePrivacyLevel === NodePrivacyLevel.HIDDEN) {
        const { width, height } = element.getBoundingClientRect();
        return {
            type: NodeType.Element,
            tagName,
            attributes: {
                rr_width: `${width}px`,
                rr_height: `${height}px`,
                [PRIVACY_ATTR_NAME]: PRIVACY_ATTR_VALUE_HIDDEN,
            },
            childNodes: [],
            isSVG,
        };
    }
    // Ignore Elements like Script and some Link, Metas
    if (nodePrivacyLevel === NodePrivacyLevel.IGNORE) {
        return;
    }
    const attributes = serializeAttributes(element, nodePrivacyLevel, options);
    let childNodes = [];
    if (hasChildNodes(element) &&
        // Do not serialize style children as the css rules are already in the _cssText attribute
        tagName !== 'style') {
        childNodes = serializeChildNodes(element, nodePrivacyLevel, options);
    }
    return {
        type: NodeType.Element,
        tagName,
        attributes,
        childNodes,
        isSVG,
    };
}
function isSVGElement(el) {
    return el.tagName === 'svg' || el instanceof SVGElement;
}
/**
 * Text Nodes are dependant on Element nodes
 * Privacy levels are set on elements so we check the parentElement of a text node
 * for privacy level.
 */
function serializeTextNode(textNode, parentNodePrivacyLevel) {
    const textContent = getTextContent(textNode, parentNodePrivacyLevel);
    if (textContent === undefined) {
        return;
    }
    return {
        type: NodeType.Text,
        textContent,
    };
}
function serializeCDataNode() {
    return {
        type: NodeType.CDATA,
        textContent: '',
    };
}
//# sourceMappingURL=serializeNode.js.map