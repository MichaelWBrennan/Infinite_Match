import { asyncRunOnReadyState, monitorError, Observable } from '@datadog/browser-core';
import { getSessionReplayLink } from '../domain/getSessionReplayLink';
import { startRecorderInitTelemetry } from '../domain/startRecorderInitTelemetry';
export function createPostStartStrategy(configuration, lifeCycle, sessionManager, viewHistory, loadRecorder, getOrCreateDeflateEncoder, telemetry) {
    let status = 0 /* RecorderStatus.Stopped */;
    let stopRecording;
    lifeCycle.subscribe(9 /* LifeCycleEventType.SESSION_EXPIRED */, () => {
        if (status === 2 /* RecorderStatus.Starting */ || status === 3 /* RecorderStatus.Started */) {
            stop();
            status = 1 /* RecorderStatus.IntentToStart */;
        }
    });
    lifeCycle.subscribe(10 /* LifeCycleEventType.SESSION_RENEWED */, () => {
        if (status === 1 /* RecorderStatus.IntentToStart */) {
            start();
        }
    });
    const observable = new Observable();
    startRecorderInitTelemetry(telemetry, observable);
    const doStart = async (forced) => {
        observable.notify({ type: 'start', forced });
        const [startRecordingImpl] = await Promise.all([
            notifyWhenSettled(observable, { type: 'recorder-settled' }, loadRecorder()),
            notifyWhenSettled(observable, { type: 'document-ready' }, asyncRunOnReadyState(configuration, 'interactive')),
        ]);
        if (status !== 2 /* RecorderStatus.Starting */) {
            observable.notify({ type: 'aborted' });
            return;
        }
        if (!startRecordingImpl) {
            status = 0 /* RecorderStatus.Stopped */;
            observable.notify({ type: 'recorder-load-failed' });
            return;
        }
        const deflateEncoder = getOrCreateDeflateEncoder();
        if (!deflateEncoder) {
            status = 0 /* RecorderStatus.Stopped */;
            observable.notify({ type: 'deflate-encoder-load-failed' });
            return;
        }
        ;
        ({ stop: stopRecording } = startRecordingImpl(lifeCycle, configuration, sessionManager, viewHistory, deflateEncoder, telemetry));
        status = 3 /* RecorderStatus.Started */;
        observable.notify({ type: 'succeeded' });
    };
    function start(options) {
        const session = sessionManager.findTrackedSession();
        if (canStartRecording(session, options)) {
            status = 1 /* RecorderStatus.IntentToStart */;
            return;
        }
        if (isRecordingInProgress(status)) {
            return;
        }
        status = 2 /* RecorderStatus.Starting */;
        const forced = shouldForceReplay(session, options) || false;
        // Intentionally not awaiting doStart() to keep it asynchronous
        doStart(forced).catch(monitorError);
        if (forced) {
            sessionManager.setForcedReplay();
        }
    }
    function stop() {
        if (status === 3 /* RecorderStatus.Started */) {
            stopRecording === null || stopRecording === void 0 ? void 0 : stopRecording();
        }
        status = 0 /* RecorderStatus.Stopped */;
    }
    return {
        start,
        stop,
        getSessionReplayLink() {
            return getSessionReplayLink(configuration, sessionManager, viewHistory, status !== 0 /* RecorderStatus.Stopped */);
        },
        isRecording: () => status === 3 /* RecorderStatus.Started */,
    };
}
function canStartRecording(session, options) {
    return !session || (session.sessionReplay === 0 /* SessionReplayState.OFF */ && (!options || !options.force));
}
function isRecordingInProgress(status) {
    return status === 2 /* RecorderStatus.Starting */ || status === 3 /* RecorderStatus.Started */;
}
function shouldForceReplay(session, options) {
    return options && options.force && session.sessionReplay === 0 /* SessionReplayState.OFF */;
}
async function notifyWhenSettled(observable, event, promise) {
    try {
        return await promise;
    }
    finally {
        observable.notify(event);
    }
}
//# sourceMappingURL=postStartStrategy.js.map